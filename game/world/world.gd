class_name World
extends Node2D

"""This demo shows how to evolve arcade-style cars to successfully complete a track.
This is accomplished by assigning fitness based on how many degrees around the track
a car has driven, and regularly starting a new generation where the fittest individuals
are more prevalent.

New generations are started based on a timer (generation_step), because a lot of
cars end up just loitering around the track, and I haven't implemented a method
to detect this yet. This may cause successful agents to be stopped prematurely however.
"""

signal clock_tick(world: World)
signal gen_tick(world: World)

const MAX_FOOD = 1000
@onready var SLIME_SPAWN_MIN = Vector2.ZERO
@onready var SLIME_SPAWN_MAX = 3 * get_viewport_rect().size / 2
@onready var FOOD_SPAWN_MIN = -4 * get_viewport_rect().size
@onready var FOOD_SPAWN_MAX = 4 * get_viewport_rect().size

var clock: Timer
var curr_clock_time: int = 0
var time_since_last_gen: int = 0
# every generation_step a new generation is made. this gets increased over time.
var generation_step: int = 60

# fitness treshold is 100 secs
var fitness_threshold = 100

var is_ready = false

var slimes = []
var food_items = []

@onready var food_scene: Resource = preload("res://game/food/food.tscn")
@onready var ga: GeneticAlgorithm = GeneticAlgorithm.new(23, 5, "res://game/slime/slime.tscn")

func _ready() -> void:
	"""creates ga, adds the GeneticAlgorithm node as a child and places
	the agent_bodies at the starting position of the track.
	"""
	reset_food()
	add_child(ga)
	add_initial_slimes()
	clock_tick.emit(self)
	clock = Timer.new()
	add_child(clock)
	clock.wait_time = 1.0
	clock.timeout.connect(_on_clock_time_step)
	clock.start()
	is_ready = true
	
#func _process(delta: float) -> void:
	#$BackgroundTrails.draw_trails(slimes)
	
func _generate_random_pos(_min: Vector2, _max: Vector2):
	var random = RandomNumberGenerator.new()
	var random_pos = Vector2(
		random.randf_range(_min.x, _max.x), 
		random.randf_range(_min.y, _max.y)) - global_position
	return random_pos

func _on_clock_time_step() -> void:
	curr_clock_time += 1
	clock_tick.emit(self)
	time_since_last_gen += 1
	
	var are_all_agents_dead = true
	for agent in ga.curr_agents:
		if not agent.is_dead:
			are_all_agents_dead = false
			break
			
	if are_all_agents_dead:
		curr_clock_time += generation_step - time_since_last_gen
	
	if curr_clock_time % generation_step == 0:
		gen_tick.emit(self)
		time_since_last_gen = 0
		var highest_agent_age = 0.0
		for agent in ga.curr_agents:
			highest_agent_age = maxf(highest_agent_age, agent.get_age())
		print("The oldest agent lived for " + str(highest_agent_age))
		
		print("=====Generation Step=====")
		ga.evaluate_generation()
		print("=========================")
		slimes.clear()
		reset_food()
		ga.next_generation()
		
		print(ga.curr_agents.size(), " agents were spawned")
		for agent in ga.curr_agents:
			agent.body.position = _generate_random_pos(
			SLIME_SPAWN_MIN,
			SLIME_SPAWN_MAX)
			agent.body.rotation = RandomNumberGenerator.new().randf_range(0, 2 * PI)
			add_child(agent.body)
			slimes.append(agent.body)
		
		# if folks start crossing the generation_step bound, increase the generation_step
		if generation_step < 15 and highest_agent_age >= generation_step - 1:
			generation_step += 15
			print("Increased gen step to " + str(generation_step))
		
	

func add_initial_slimes() -> void:
	"""Adds the bodies scenes generated by the ga to the tree, and removes the old ones.
	"""
	for i in Params.population_size:
		var agent = ga.create_initial_agent()
		agent.body.position = _generate_random_pos(
			SLIME_SPAWN_MIN,
			SLIME_SPAWN_MAX)
		agent.body.rotation = RandomNumberGenerator.new().randf_range(-PI, PI)
		add_child(agent.body)
		slimes.append(agent.body)
		

func reset_food() -> void:
	var _food_items = get_tree().get_nodes_in_group("food")
	for food in _food_items:
		food.position = _generate_random_pos(FOOD_SPAWN_MIN, FOOD_SPAWN_MAX)
		
	var missing_count = MAX_FOOD - _food_items.size()
	print(missing_count, " new food items were added to the existing ", _food_items.size())
	for i in missing_count:
		var food = food_scene.instantiate() as Area2D
		food.position = _generate_random_pos(FOOD_SPAWN_MIN, FOOD_SPAWN_MAX)
		add_child(food)
