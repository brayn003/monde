class_name World
extends Node2D

"""This demo shows how to evolve arcade-style cars to successfully complete a track.
This is accomplished by assigning fitness based on how many degrees around the track
a car has driven, and regularly starting a new generation where the fittest individuals
are more prevalent.

New generations are started based on a timer (generation_step), because a lot of
cars end up just loitering around the track, and I haven't implemented a method
to detect this yet. This may cause successful agents to be stopped prematurely however.
"""

signal clock_tick(world: World)
signal gen_tick(world: World)

const MAX_FOOD = 500
const SLIME_SPAWN_HEIGHT = 2000
const SLIME_SPAWN_WIDTH = 4000
const SLIME_SPAWN_OFFSET = Vector2.ZERO
const FOOD_SPAWN_HEIGHT = 2000
const FOOD_SPAWN_WIDTH = 2000
const FOOD_SPAWN_OFFSET = Vector2(0, 0)

var clock: Timer
var curr_clock_time: int = 0
var time_since_last_gen: int = 0
# every generation_step a new generation is made. this gets increased over time.
var generation_step: int = 15

# fitness treshold is 100 secs
var fitness_threshold = 100

var is_ready = false

var slimes = []
var food_items = []

@onready var food_scene: Resource = preload("res://scenes/food.tscn")
@onready var ga: GeneticAlgorithm = GeneticAlgorithm.new(19, 4, "res://scenes/Slime.tscn")

func _ready() -> void:
	"""creates ga, adds the GeneticAlgorithm node as a child and places
	the agent_bodies at the starting position of the track.
	"""
	reset_food()
	add_child(ga)
	add_initial_slimes()
	clock_tick.emit(self)
	clock = Timer.new()
	add_child(clock)
	clock.wait_time = 1.0
	clock.timeout.connect(_on_clock_time_step)
	clock.start()
	is_ready = true
	
#func _process(delta: float) -> void:
	#$BackgroundTrails.draw_trails(slimes)
	
func _generate_random_vector(
	width = 2000, 
	height = 1000):
	var random = RandomNumberGenerator.new()
	var random_pos = Vector2(
		random.randf_range(0, width), 
		random.randf_range(0, height))
	return random_pos

func _on_clock_time_step() -> void:
	curr_clock_time += 1
	clock_tick.emit(self)
	time_since_last_gen += 1
	
	var are_all_agents_dead = true
	for agent in ga.curr_agents:
		if not agent.is_dead:
			are_all_agents_dead = false
			break
			
	if are_all_agents_dead:
		curr_clock_time += generation_step - time_since_last_gen
	
	if curr_clock_time % generation_step == 0:
		gen_tick.emit(self)
		time_since_last_gen = 0
		var highest_agent_age = 0.0
		for agent in ga.curr_agents:
			highest_agent_age = maxf(highest_agent_age, agent.get_age())
		print("The oldest agent lived for " + str(highest_agent_age))
		
		print("=====Generation Step=====")
		ga.evaluate_generation()
		print("=========================")
		slimes.clear()
		reset_food()
		ga.next_generation()
		
		print(ga.curr_agents.size(), " agents were spawned")
		for agent in ga.curr_agents:
			agent.body.position = _generate_random_vector(
			SLIME_SPAWN_WIDTH,
			SLIME_SPAWN_HEIGHT)
			agent.body.rotation = RandomNumberGenerator.new().randf_range(0, 2 * PI)
			add_child(agent.body)
			slimes.append(agent.body)
		
		# if folks start crossing the generation_step bound, increase the generation_step
		if generation_step < 15 and highest_agent_age >= generation_step - 1:
			generation_step += 15
			print("Increased gen step to " + str(generation_step))
		
	

func add_initial_slimes() -> void:
	"""Adds the bodies scenes generated by the ga to the tree, and removes the old ones.
	"""
	for i in Params.population_size:
		var agent = ga.create_initial_agent()
		agent.body.position = _generate_random_vector(
			SLIME_SPAWN_WIDTH,
			SLIME_SPAWN_HEIGHT)
		agent.body.rotation = RandomNumberGenerator.new().randf_range(0, 2 * PI)
		add_child(agent.body)
		slimes.append(agent.body)
		

func reset_food() -> void:
	var food_items = get_tree().get_nodes_in_group("food")
	for food in food_items:
		food.position = _generate_random_vector(
			FOOD_SPAWN_WIDTH,
			FOOD_SPAWN_HEIGHT)
		
	var missing_count = MAX_FOOD - food_items.size()
	print(missing_count, " new food items were added to the existing ", food_items.size())
	for i in missing_count:
		var food = food_scene.instantiate() as Area2D
		food.position = _generate_random_vector(
			FOOD_SPAWN_WIDTH,
			FOOD_SPAWN_HEIGHT)
		add_child(food)
